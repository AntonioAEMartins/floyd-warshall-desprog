<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <title>Algoritmo de Floyd-Warshall</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400;0,700;1,400;1,700&family=Open+Sans+Condensed:ital,wght@0,300;1,300&family=Open+Sans:ital,wght@0,300;0,400;0,700;0,800;1,300;1,400;1,700;1,800&family=Oxygen+Mono&family=Josefin+Sans:ital,wght@0,200;0,600;1,200;1,600&display=swap">
        <link rel="stylesheet" href="assets/css/reset.css">
        <link rel="stylesheet" href="assets/css/highlight.css">
        <link rel="stylesheet" href="assets/css/style.css">
        <link rel="stylesheet" href="assets/css/color.css">
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script async src="https://static.codepen.io/assets/embed/ei.js"></script>
        <script src="assets/js/highlight.js"></script>
        <script src="assets/js/script.js"></script>
    </head>
    <body>
        <div class="container">
            <header>
                <a href="">abrir tudo</a>
                <a href="">fechar tudo</a>
            </header>
            <main>

<h1>Algoritmo de Floyd-Warshall</h1>
<h2>Problema dos menores caminhos</h2>
<p>Imagine saber todos os caminhos possíveis entre dois pontos de um grafo, e saber qual o menor caminho entre eles. Esse é o problema dos menores caminhos, e o algoritmo de Floyd-Warshall é uma solução para esse problema.</p>
<figure class="img"><img src="img/cubo-arvore.png" alt="" style="max-height: 20em;"></figure>
<h2>Grafos como Matrizes</h2>
<p><img src="img/Exemplos/Grafo-Exemplo1.png" alt="">
<img src="img/Exemplos/Matriz-Grafo1.png" alt=""></p>
<p>Este é um exemplo de grafo muito utilizado, existem 4 nodos que estão conectados por caminhos com pesos diferentes. O nosso computador, porém, não têm a capacidade de receber como input este grafo, ele têm que ser guardado em um formato de dados que represente todos os nodos e seus pesos.</p>
<p>Este formato pode ir desde listas, pilhas, filas… porém nenhum destes modelos consegue representar todas as possibilidades de expansão de um grafo, por isso, o modelo mais utilizado é o de Matrizes.</p>
<p>Mas como que uma matriz pode representar um grafo? Para isso existem regras de construção:</p>
<ol>
<li>A matriz deve ser quadrada, ou seja, o número de linhas deve ser igual ao número de colunas.</li>
<li>A distância/peso de um Node para ele mesmo é igual a 0.</li>
<li>Se não existe uma aresta entre dois Nodes, o peso é igual a zero.</li>
<li>Se existe uma aresta entre dois Nodes, o peso é igual ao peso da aresta.</li>
</ol>
<p>A 3° regra é uma excessão, que será utilizada para melhor entendimento dos conceitos inicias, posteriormente será tratada novamente com outra definição.</p>
<p><em>Dica: Construa a Matriz das linhas para as colunas. Então se estiver na Coluna A e Linha B, o peso da aresta é o peso da flecha que liga o Node A ao Node B - e não o inverso.</em></p>
<blockquote class="question">
<p>Checkpoint</p>
<p>Qual a matriz de pesos do Grafo abaixo?</p>
<figure class="img"><img src="img/Exemplo-1.png" alt="" style="max-height: 13em;"></figure>
<details class="answer">
<summary>Gabarito</summary>
<figure class="img"><img src="img/matriz-exemplo.png" alt=""></figure>
<p>Se conseguiu completar corretamente, quer dizer que já entendeu os objetivos, e pode seguir para o próximo Checkpoint. Se não compreendeu é importante ler as regras novamente e ver se ao construir sua Matriz seguiu todas elas.</p>
</details>
</blockquote>
<p>Com todos os pesos dos nodos em uma matriz podemos encontrar o caminho de menor peso entre dois nodos. Pensei na melhor forma de encontrar o menor caminho e aplique este formato nos checkpoints abaixo.</p>
<blockquote class="question">
<p>Checkpoint</p>
<p>Qual o menor caminho entre o Nodo A e B?</p>
<figure class="img"><img src="img/Exemplos/Checkpoint2.png" alt=""></figure>
<details class="answer">
<summary>Gabarito</summary>
<p>O menor caminho entre A e B é ir pelo nodo C que têm peso 5, e depois de C chegar em B, tendo um peso total de 6 - contra o caminho convencional de 7.</p>
</details>
</blockquote>
<blockquote class="question">
<p>Checkpoint</p>
<p>Qual o menor caminho entre o nodo B e C?</p>
<figure class="img"><img src="img/Exemplos/Checkpoint2.png" alt=""></figure>
<details class="answer">
<summary>Gabarito</summary>
<p>O menor caminho entre B e C é ir pelo nodo A que têm peso 5 e depois ir para o nodo C com um peso total de 6 - contra o caminho convencional de 10.</p>
</details>
</blockquote>
<p>Você deve estar achando o problema muito fácil, basta analisarmos os nodos e seus pesos e encontrarmos o caminho com menor peso. Porém, perceba que estamos apenas buscando pesos entre dois nodos de um Grafo com 3 nodos. Se aumentarmos o tamanho do problema e pedirmos para encontrar todos os menores caminhos em todos os nodos consumirá mais tempo.</p>
<blockquote class="question">
<p>Checkpoint</p>
<p>Qual o menor caminho entre todos os nodos?</p>
<figure class="img"><img src="img/Exemplos/Grafo-Checkpoint3-desafio.png" alt=""></figure>
<details class="answer">
<summary>Gabarito</summary>
<p>Tenho certeza que você nem tentou resolver e já abriu o gabarito. Mas tudo bem, não esperamos que você resolva este Checkpoint, se quiser algo realmente dificil, desça até os desafios.</p>
</details>
</blockquote>
<p>Você deve ter percebido que é extremamente trabalhoso encontrar o menor caminho para cada um dos casos, e conforme o grafo se torna mais complexo, se torna mais dificil encontrar. Por isso, o algoritmo de Floyd-Warshall foi criado, para encontrar todos os menores caminhos de um grafo de forma eficiente - e entregar a resposta em uma matriz de mesmo tamanho que a inicial.</p>
<h2>O que é o Algoritmo Floyd-Warshall</h2>
<p>Floyd-Warshall é um algoritmo que utiliza de programação dinâmica para encontrar todos os caminhos entre todos os Nodos de um Grafo/Matriz, dos encontrados seleciona os menores e guarda eles em uma Matriz de mesma dimensão da inicial.</p>
<p>Abaixo está um exemplo de como este algoritmo funciona, demonstrando uma das procuras dele pelo menor caminho, e construindo a matriz de distâncias passo a passo.</p>
<div class="animation"><img class="frame" src="img/Matrizes/Matriz0.png" alt="1"><img class="frame" src="img/Matrizes/Matriz1.png" alt="2"><img class="frame" src="img/Matrizes/Matriz2.png" alt="3"><img class="frame" src="img/Matrizes/Matriz3.png" alt="4"><img class="frame" src="img/Matrizes/Matriz4.png" alt="5"><img class="frame" src="img/Matrizes/Matriz5.png" alt="6"><img class="frame" src="img/Matrizes/Matriz6.png" alt="7"></div>
<p>O primeiro loop foi feito individualmente, e como é possível ver o algoritmo “trava” em um dos nodos - inicialmente o A - e calcula todos os caminhos dele para os outros nodos, replicando este processo até ter percorrido todos os possíveis caminhos em todos os nodos.</p>
<p>Para entender como o algoritmo funciona, é necessário entender como ele é implementado a nível de código, visto que a nível teórico já foi explicado.</p>
<pre><code class="language-pseudocode">função floydWarshall recebe Grafo:
    distância = Grafo
    Para k de 0 até tamanho da matriz:
        Para i de 0 até tamanho da matriz:
            Para j de 0 até tamanho da matriz:
                Se distância[i][j] &gt; distância[i][k] + distância[k][j]:
                    distância[i][j] = distância[i][k] + distância[k][j]

    retorne distância
</code></pre>
<blockquote class="question">
<p>Checkpoint</p>
<p>Olhando apenas para esse pseudocódigo, você consegue dizer qual a complexidade de tempo desse algoritmo?</p>
<details class="answer">
<summary>Gabarito</summary>
<p>Como o algoritmo utiliza 3 loops de for para percorrer todos os elementos da matriz, a complexidade de tempo é O(n³).</p>
</details>
</blockquote>
<blockquote class="question">
<p>Checkpoint</p>
<p>E qual a complexidade de espaço? Lembre-se que o algoritmo recebe uma matriz de pesos e retorna uma matriz de distâncias.</p>
<details class="answer">
<summary>Gabarito</summary>
<p>A complexidade de espaço é O(n²), pois o algoritmo utiliza uma matriz de distâncias de tamanho n².</p>
</details>
</blockquote>
<p>Agora que todos os conceitos sobre Floyd-Warshall foram demonstrados, você já viu a teória, sabe transformar um Grafo em Matriz e têm ideia de como implementar o código. Vamos voltar para tratar das regras e estabelecer elas definitivamente, principalmente a 3° Regra.</p>
<h2>Regras:</h2>
<figure class="table"><table>
<thead>
<tr>
<th>Regras</th>
<th>Teória</th>
<th>Prática</th>
</tr>
</thead>
<tbody>
<tr>
<td>1°</td>
<td>Matriz deve ser quadrada</td>
<td>Deve navegar todas as possibilidades</td>
</tr>
<tr>
<td>2°</td>
<td>A -&gt; A = 0</td>
<td>Não modificar input diretamente</td>
</tr>
<tr>
<td>3°</td>
<td>Se não existe aresta peso = infinito</td>
<td></td>
</tr>
<tr>
<td>4°</td>
<td>Se existir aresta peso = peso da aresta</td>
<td></td>
</tr>
</tbody>
</table></figure>
<p>Você deve ter percebido que agora ao invês de considerarmos igual a zero, estamos utilizando a notação infinito para representar que o custo de percorrer este caminho é extremamente alto - visto que não existe alternativa.</p>
<p>Outra regra adicionada recentemente é quanto a números negativos, que não serão tratados a fundo neste handout, porém é importante você saber que um dos pontos diferenciais do Algoritmo de Floyd-Warshall é que ele consegue tratar arestas com pesos negativos normalmente. Então se você se deparar com alguma situação destar apenas implemente o exercício normalmente que o resultado deve ser o esperado.</p>
<h2>Implementação do Algoritmo</h2>
<p>Agora que você já sabe como o algoritmo funciona, e quais são as regras que devem ser seguidas, vamos implementar o algoritmo.</p>
<pre><code class="language-C">int **floydWarshall(int grafo[][], int n) {
    int **dist = grafo;
    for (int k = 0; k &lt; n; k++) {
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n; j++) {
                if (dist[i][j] &gt; dist[i][k] + dist[k][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                }
            }
        }
    }
    return dist;
}
</code></pre>
<p>Nesta implementação é importante manter em mente que a função floydWarshall recebe um matriz - representada por [][], mas que também pode ser representada por ** - e o tamanho da matriz, que é representado por n. Devolvendo outra matriz de mesmo tamanho de distâncias.</p>
<h2>Exercícios</h2>
<h2>Desafios</h2>
<blockquote class="question">
<p>Desafio 1 - Google Maps</p>
<figure class="img"><img src="img/googlemaps.jpg" alt="" style="max-height: 15em;"></figure>
<p>Imagine que você trabalha na equipe de desenvolvimento do Google Maps. Recentemente, a Google vem recebendo muitas reclamações de usuários em relação à performance do aplicativo. Portanto, Você recebeu a tarefa de implementar o algoritmo de Floyd-Warshall em uma linguagem compilada, mais rápida do que a atualmente utilizada, para calcular a distância entre todos os pares de pontos de determinadas regiões. Como você é experiente em linguagem C, resolveu implementar o algoritmo nessa linguagem.</p>
<p>Desenvolva uma função <code class="language-c">floydWarshall</code>, que recebe como argumentos uma matriz de adjacência <code class="language-c">grafo</code> e o número de vértices <code class="language-c">n</code>, e retorna a matriz de distâncias <code class="language-c">dist</code>.</p>
<p>Dica: Parta do código em Python apresentado anteriormente. Como ficariam os tipos de dados?</p>
<details class="answer">
<summary>Gabarito</summary>
<pre><code class="language-c">int **floydWarshall(int grafo[][], int n) {
    int **dist = grafo;
    for (int k = 0; k &lt; n; k++) {
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n; j++) {
                if (dist[i][j] &gt; dist[i][k] + dist[k][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                }
            }
        }
    }
    return dist;
}
</code></pre>
</details>
</blockquote>
<blockquote class="question">
<p>Desafio 2 - Rede social</p>
<p>A imagem abaixo representa um grafo de uma pequena rede desenvolvida entre amigos, para uma disciplina de Engenharia da Computação do Insper. Nele, cada amigo é modelado por um vértice e cada conexão entre amigos é modelada por uma aresta. A distância entre dois amigos é dada pelo número de arestas que separam os dois vértices.</p>
<figure class="img"><img src="img/social.png" alt="" style="max-height: 20em;"></figure>
<p>O professor dessa disciplina, que é muito querido pelos alunos, quer saber qual é o par de amigos que está mais distante um do outro. Para isso vamos utilizar o algoritmo de Floyd Warshall para calcular a matriz de distâncias entre todos os pares de amigos.</p>
<p>Qual a dimensionalidade da matriz de adjacência? Represente a matriz de distâncias na PRIMEIRA iteração do algoritmo de Floyd Warshall, e no FINAL da última iteração (com todas as distâncias calculadas).</p>
<details class="answer">
<summary>Gabarito</summary>
<p>A matriz tem dimensionalidade 7x7, pois existem 7 vértices.</p>
<p>Após a primeira iteração, a matriz é a mesma da matriz de adjacência:</p>
<figure class="img"><img src="img/social-resposta-a.png" alt="" style="max-height: 20em;"></figure>
<p>Após a última iteração, a matriz é a seguinte:</p>
<figure class="img"><img src="img/social-resposta-b.png" alt="" style="max-height: 20em;"></figure>
</details>
</blockquote>


            </main>
            <footer>
                <a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">
                    <img alt="CC BY-SA 4.0" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" title="Creative Commons Attribution-ShareAlike 4.0 International License"/>
                </a>
                © 2022 Marcelo Hashimoto
            </footer>
        </div>
    </body>
</html>
